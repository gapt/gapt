package at.logic.algorithms.lk

import at.logic.calculi.lk.base.LKProof
import at.logic.calculi.occurrences.FormulaOccurrence
import at.logic.calculi.lk.propositionalRules._
import at.logic.language.hol.{Or, And}
import at.logic.calculi.lk.equationalRules.{EquationLeft2Rule, EquationRight1Rule, EquationRight2Rule, EquationLeft1Rule}
import at.logic.calculi.lk.definitionRules.{DefinitionRightRule, DefinitionLeftRule}
import at.logic.calculi.lk.quantificationRules.{ExistsRightRule, ExistsLeftRule, ForallRightRule, ForallLeftRule}

/**
 * eliminates all formulas in the end sequent generated by weakenings
 * we eliminate for now only formulas A occurring in the end sequent if there is a weakening on A in the proof,
 * we do not deal with formulas containing subformulas which are introduced by weakening
 * specific formulas can later be added by weakenings if required
 */
object WeakeningsElimination {
  def apply(proof: LKProof): LKProof = {
    val formulas = proof.root.antecedent ++ proof.root.succedent
    applyRec(proof,formulas)
  }

  private def applyRec(proof: LKProof, forms: Iterable[FormulaOccurrence]): LKProof = proof match {
    case Axiom(s) => Axiom(s)
    case WeakeningLeftRule(p,s,o) if (forms.exists(x => x.isAncestor(o) && o.formula == x.formula)) => applyRec(p, forms)
    case WeakeningLeftRule(p,_,o) => WeakeningLeftRule(applyRec(p,forms), o.formula)
    case WeakeningRightRule(p,_,o) if (forms.exists(x => x.isAncestor(o) && o.formula == x.formula)) => applyRec(p, forms)
    case WeakeningRightRule(p,_,o) => WeakeningRightRule(applyRec(p,forms), o.formula)
    case ContractionLeftRule(p,_,a1,_,_) => ContractionLeftRule(applyRec(p,forms),a1.formula)
    case ContractionRightRule(p,_,a1,_,_) => ContractionRightRule(applyRec(p,forms),a1.formula)
    case CutRule(p1,p2,_,o1,_) => CutRule(applyRec(p1,forms),applyRec(p2,forms),o1.formula)
    case AndRightRule(p1,p2,_,o1,o2,_) => AndRightRule(applyRec(p1,forms),applyRec(p2,forms),o1.formula,o2.formula)
    case OrLeftRule(p1,p2,_,o1,o2,_) => OrLeftRule(applyRec(p1,forms),applyRec(p2,forms),o1.formula,o2.formula)
    case AndLeft1Rule(p,_,_,fo) => {val And(f1,f2) = fo.formula; AndLeft1Rule(applyRec(p, forms),f1,f2)}
    case AndLeft2Rule(p,_,_,fo) => {val And(f1,f2) = fo.formula; AndLeft2Rule(applyRec(p, forms),f1,f2)}
    case OrRight1Rule(p,_,_,fo) => {val Or(f1,f2) = fo.formula; OrRight1Rule(applyRec(p, forms),f1,f2)}
    case OrRight2Rule(p,_,_,fo) => {val Or(f1,f2) = fo.formula; OrRight2Rule(applyRec(p, forms),f1,f2)}
    case ImpLeftRule(p1,p2,_,o1,o2,_) => ImpLeftRule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula)
    case ImpRightRule(p1,_,o1,o2,_) => ImpRightRule(applyRec(p1, forms),o1.formula,o2.formula)
    case NegRightRule(p1,_,o1,_) => NegRightRule(applyRec(p1, forms),o1.formula)
    case NegLeftRule(p1,_,o1,_) => NegLeftRule(applyRec(p1, forms),o1.formula)
    case EquationLeft1Rule(p1,p2,_,o1,o2,o3) => EquationLeft1Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case EquationLeft2Rule(p1,p2,_,o1,o2,o3) => EquationLeft2Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case EquationRight1Rule(p1,p2,_,o1,o2,o3) => EquationRight1Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case EquationRight2Rule(p1,p2,_,o1,o2,o3) => EquationRight2Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case DefinitionLeftRule(p1,_,o1,o2) => DefinitionLeftRule(applyRec(p1, forms),o1.formula,o2.formula)
    case DefinitionRightRule(p1,_,o1,o2) => DefinitionRightRule(applyRec(p1, forms),o1.formula,o2.formula)
    case ForallLeftRule(p1,_,o1,o2,e) => ForallLeftRule(applyRec(p1, forms),o1.formula,o2.formula,e)
    case ForallRightRule(p1,_,o1,o2,e) => ForallRightRule(applyRec(p1, forms),o1.formula,o2.formula,e)
    case ExistsLeftRule(p1,_,o1,o2,e) => ExistsLeftRule(applyRec(p1, forms),o1.formula,o2.formula,e)
    case ExistsRightRule(p1,_,o1,o2,e) => ExistsRightRule(applyRec(p1, forms),o1.formula,o2.formula,e)
  }

}