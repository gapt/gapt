package at.logic.algorithms.lk

import at.logic.calculi.lk.base._
import at.logic.calculi.occurrences.FormulaOccurrence
import at.logic.calculi.lk.propositionalRules._
import at.logic.language.hol._
import at.logic.language.schema.{And => AndS, Or => OrS, SchemaFormula}
import at.logic.calculi.slk._
import at.logic.calculi.lk.equationalRules.{EquationLeft2Rule, EquationRight1Rule, EquationRight2Rule, EquationLeft1Rule}
import at.logic.calculi.lk.definitionRules.{DefinitionRightRule, DefinitionLeftRule}
import at.logic.calculi.lk.quantificationRules.{ExistsRightRule, ExistsLeftRule, ForallRightRule, ForallLeftRule}

/**
 * eliminates all formulas in the end sequent generated by weakenings
 * we eliminate for now only formulas A occurring in the end sequent if there is a weakening on A in the proof,
 * we do not deal with formulas containing subformulas which are introduced by weakening
 * specific formulas can later be added by weakenings if required
 */
object WeakeningsElimination {
  def apply(proof: LKProof): LKProof = {
    val formulas = proof.root.antecedent ++ proof.root.succedent
    applyRec(proof,formulas)
  }

  private def applyRec(proof: LKProof, forms: Iterable[FormulaOccurrence]): LKProof = proof match {
    case Axiom(s) => Axiom(s)
    case WeakeningLeftRule(p,s,o) if (forms.exists(x => x.isAncestor(o) && o.formula == x.formula)) => applyRec(p, forms)
    case WeakeningLeftRule(p,_,o) => WeakeningLeftRule(applyRec(p,forms), o.formula)
    case WeakeningRightRule(p,_,o) if (forms.exists(x => x.isAncestor(o) && o.formula == x.formula)) => applyRec(p, forms)
    case WeakeningRightRule(p,_,o) => WeakeningRightRule(applyRec(p,forms), o.formula)
    case ContractionLeftRule(p,_,a1,_,_) => ContractionLeftRule(applyRec(p,forms),a1.formula)
    case ContractionRightRule(p,_,a1,_,_) => ContractionRightRule(applyRec(p,forms),a1.formula)
    case CutRule(p1,p2,_,o1,_) => CutRule(applyRec(p1,forms),applyRec(p2,forms),o1.formula)
    case AndRightRule(p1,p2,_,o1,o2,_) => AndRightRule(applyRec(p1,forms),applyRec(p2,forms),o1.formula,o2.formula)
    case OrLeftRule(p1,p2,_,o1,o2,_) => OrLeftRule(applyRec(p1,forms),applyRec(p2,forms),o1.formula,o2.formula)
    case AndLeft1Rule(p,_,_,fo) => 
      val And(f1, f2) = fo.formula
      AndLeft1Rule(applyRec(p, forms), f1.asInstanceOf[HOLFormula], f2.asInstanceOf[HOLFormula])
    case AndLeft2Rule(p,_,_,fo) => 
      val And(f1, f2) = fo.formula
      AndLeft2Rule(applyRec(p, forms), f1.asInstanceOf[HOLFormula], f2.asInstanceOf[HOLFormula])
    case OrRight1Rule(p,_,_,fo) => 
      val Or(f1, f2) = fo.formula
      OrRight1Rule(applyRec(p, forms), f1.asInstanceOf[HOLFormula], f2.asInstanceOf[HOLFormula])
    case OrRight2Rule(p,_,_,fo) => 
      val Or(f1, f2) = fo.formula
      OrRight2Rule(applyRec(p, forms), f1.asInstanceOf[HOLFormula], f2.asInstanceOf[HOLFormula])
    case ImpLeftRule(p1,p2,_,o1,o2,_) => ImpLeftRule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula)
    case ImpRightRule(p1,_,o1,o2,_) => ImpRightRule(applyRec(p1, forms),o1.formula,o2.formula)
    case NegRightRule(p1,_,o1,_) => NegRightRule(applyRec(p1, forms),o1.formula)
    case NegLeftRule(p1,_,o1,_) => NegLeftRule(applyRec(p1, forms),o1.formula)
    case EquationLeft1Rule(p1,p2,_,o1,o2,o3) => EquationLeft1Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case EquationLeft2Rule(p1,p2,_,o1,o2,o3) => EquationLeft2Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case EquationRight1Rule(p1,p2,_,o1,o2,o3) => EquationRight1Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case EquationRight2Rule(p1,p2,_,o1,o2,o3) => EquationRight2Rule(applyRec(p1, forms),applyRec(p2, forms),o1.formula,o2.formula,o3.formula)
    case DefinitionLeftRule(p1,_,o1,o2) => DefinitionLeftRule(applyRec(p1, forms),o1.formula,o2.formula)
    case DefinitionRightRule(p1,_,o1,o2) => DefinitionRightRule(applyRec(p1, forms),o1.formula,o2.formula)
    case ForallLeftRule(p1,_,o1,o2,e) => ForallLeftRule(applyRec(p1, forms),o1.formula,o2.formula,e)
    case ForallRightRule(p1,_,o1,o2,e) => ForallRightRule(applyRec(p1, forms),o1.formula,o2.formula,e)
    case ExistsLeftRule(p1,_,o1,o2,e) => ExistsLeftRule(applyRec(p1, forms),o1.formula,o2.formula,e)
    case ExistsRightRule(p1,_,o1,o2,e) => ExistsRightRule(applyRec(p1, forms),o1.formula,o2.formula,e)
  }

}

// Removes the redundant weakenings and contractions.
// Traverse the proof top-down.
// When a contraction is encountered, check if the formulas are later weakened
// and remove both rules (contraction and weakening)
object cleanStructuralRules {

  def apply(p: LKProof) : LKProof = cleanStructuralRules(p)

  private def cleanStructuralRules(proof: LKProof) : LKProof = proof match {
    // Base case: axiom
    case Axiom(s) => proof 

    // Structural rules:
    case WeakeningLeftRule(p, _, m) =>
      val new_proof = cleanStructuralRules(p)
      WeakeningLeftRule(new_proof, m.formula)
    
    case WeakeningRightRule(p, _, m) =>
      val new_proof = cleanStructuralRules(p)
      WeakeningRightRule(new_proof, m.formula)

    case ContractionLeftRule(p, _, a1, a2, m) =>
      // Assuming that above this contraction there are no more redundant
      // contractions (it is the top most)
      val new_proof = cleanStructuralRules(p)

      // Finding corresponding occurrences on the new proof (both should be there!!!)
      val new_a1 = new_proof.root.antecedent.filter(x => x =^ a1)(0)
      val new_a2 = new_proof.root.antecedent.filter(x => x =^ a2)(1)

      val w1 = isWeakened(new_a1, new_proof)
      val w2 = isWeakened(new_a2, new_proof)
      
      // Both formulas are weakened at some point
      if(w1 && w2) {
        // Only remove the weakening of one of those
        // NOTE: By returning this proof, the contraction rule is automatically
        // removed.
        removeWeakeningOn(new_a1, new_proof)
      }
      // Only one formula is weakened
      else if(w1) {
        removeWeakeningOn(new_a1, new_proof)
      }
      else if (w2) {
        removeWeakeningOn(new_a2, new_proof)
      }
      // No formulas are weakened, leave contraction there
      else ContractionLeftRule(new_proof, a1.formula)

    case ContractionRightRule(p, _, a1, a2, m) =>
      // Assuming that above this contraction there are no more redundant
      // contractions (it is the top most)
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrences on the new proof (both should be there!!!)
      val new_a1 = new_proof.root.succedent.filter(x => x =^ a1)(0)
      val new_a2 = new_proof.root.succedent.filter(x => x =^ a2)(1)

      val w1 = isWeakened(new_a1, new_proof)
      val w2 = isWeakened(new_a2, new_proof)
      
      // Both formulas are weakened at some point
      if(w1 && w2) {
        // Only remove the weakening of one of those
        // NOTE: By returning this proof, the contraction rule is automatically
        // removed.
        removeWeakeningOn(new_a1, new_proof)
      }
      // Only one formula is weakened
      else if(w1) {
        removeWeakeningOn(new_a1, new_proof)
      }
      else if (w2) {
        removeWeakeningOn(new_a2, new_proof)
      }
      // No formulas are weakened, leave contraction there
      else ContractionRightRule(new_proof, a1.formula)

    case CutRule(p1, p2, _, a1, a2) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      CutRule(new_proof1, new_proof2, a1.formula)

    // Logical rules:
    case OrLeftRule(p1, p2, _, a1, a2, m) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)

      // Finding corresponding occurrences on the new proofs
      val new_a1 = new_proof1.root.antecedent.filter(x => x =^ a1)(0)
      val new_a2 = new_proof2.root.antecedent.filter(x => x =^ a2)(0)

      val w1 = isWeakened(new_a1, new_proof1)
      val w2 = isWeakened(new_a2, new_proof2)

      if(w1) {
        val new_proof12 = removeWeakeningOn(new_a1, new_proof1)
        addWeakenings(new_proof12, proof.root)
      }
      else if(w2) {
        val new_proof22 = removeWeakeningOn(new_a2, new_proof2)
        addWeakenings(new_proof22, proof.root)
      }
      else OrLeftRule(new_proof1, new_proof2, a1.formula, a2.formula)
    
    case AndRightRule(p1, p2, _, a1, a2, m) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      
      // Finding corresponding occurrences on the new proofs
      val new_a1 = new_proof1.root.succedent.filter(x => x =^ a1)(0)
      val new_a2 = new_proof2.root.succedent.filter(x => x =^ a2)(0)

      val w1 = isWeakened(new_a1, new_proof1)
      val w2 = isWeakened(new_a2, new_proof2)

      if(w1) {
        val new_proof12 = removeWeakeningOn(new_a1, new_proof1)
        addWeakenings(new_proof12, proof.root)
      }
      else if(w2) {
        val new_proof22 = removeWeakeningOn(new_a2, new_proof2)
        addWeakenings(new_proof22, proof.root)
      }
      else AndRightRule(new_proof1, new_proof2, a1.formula, a2.formula)
    
    case NegLeftRule(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.succedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningLeftRule(new_proof2, m.formula)
      }
      else NegLeftRule(new_proof, a.formula)
    
    case AndLeft1Rule(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      val a2 = m.formula match {case And(_,r) => r}

      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.antecedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningLeftRule(new_proof2, m.formula)
      }
      else AndLeft1Rule(new_proof, a.formula, a2.asInstanceOf[HOLFormula])
    
    case AndLeft2Rule(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      val a2 = m.formula match {case And(l,_) => l}
     
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.antecedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningLeftRule(new_proof2, m.formula)
      }
      else AndLeft2Rule(new_proof, a2.asInstanceOf[HOLFormula], a.formula)
    
    case OrRight1Rule(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      val a2 = m.formula match {case Or(_,r) => r}
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.succedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningRightRule(new_proof2, m.formula)
      }
      else OrRight1Rule(new_proof, a.formula, a2.asInstanceOf[HOLFormula])
    
    case OrRight2Rule(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      val a2 = m.formula match {case Or(l,_) => l}
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.succedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningRightRule(new_proof2, m.formula)
      }
      else OrRight2Rule(new_proof, a2.asInstanceOf[HOLFormula], a.formula)
    
    case NegRightRule(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.antecedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningRightRule(new_proof2, m.formula)
      }
      else NegRightRule(new_proof, a.formula)
    
    case ImpLeftRule(p1, p2, _, a1, a2, m) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      
      // Finding corresponding occurrences on the new proofs
      val new_a1 = new_proof1.root.succedent.filter(x => x =^ a1)(0)
      val new_a2 = new_proof2.root.antecedent.filter(x => x =^ a2)(0)

      val w1 = isWeakened(new_a1, new_proof1)
      val w2 = isWeakened(new_a2, new_proof2)

      if(w1) {
        val new_proof12 = removeWeakeningOn(new_a1, new_proof1)
        addWeakenings(new_proof12, proof.root)
      }
      else if(w2) {
        val new_proof22 = removeWeakeningOn(new_a2, new_proof2)
        addWeakenings(new_proof22, proof.root)
      }
      else ImpLeftRule(new_proof1, new_proof2, a1.formula, a2.formula)
    
    case ImpRightRule(p, _, a1, a2, m) =>
      val new_proof = cleanStructuralRules(p)
      ImpRightRule(new_proof, a1.formula, a2.formula)

    case ForallLeftRule(p, _, a, m, t) => 
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.antecedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningLeftRule(new_proof2, m.formula)
      }
      else ForallLeftRule(new_proof, a.formula, m.formula, t)

    case ForallRightRule(p, _, a, m, t) => 
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.succedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningRightRule(new_proof2, m.formula)
      }
      else ForallRightRule(new_proof, a.formula, m.formula, t)

    case ExistsLeftRule(p, _, a, m, t) => 
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.antecedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningLeftRule(new_proof2, m.formula)
      }
      else ExistsLeftRule(new_proof, a.formula, m.formula, t)

    case ExistsRightRule(p, _, a, m, t) => 
      val new_proof = cleanStructuralRules(p)
      
      // Finding corresponding occurrence on the new proof
      val new_a = new_proof.root.succedent.filter(x => x =^ a)(0)

      val w1 = isWeakened(new_a, new_proof)
      
      if(w1) {
        val new_proof2 = removeWeakeningOn(new_a, new_proof)
        WeakeningRightRule(new_proof2, m.formula)
      }
      else ExistsRightRule(new_proof, a.formula, m.formula, t)

    case EquationLeft1Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      EquationLeft1Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case EquationLeft2Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      EquationLeft2Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case EquationRight1Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      EquationRight1Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case EquationRight2Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = cleanStructuralRules(p1)
      val new_proof2 = cleanStructuralRules(p2)
      EquationRight2Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case DefinitionLeftRule(p1,_,o1,o2) =>
      val new_proof = cleanStructuralRules(p1)
      DefinitionLeftRule(new_proof,o1.formula,o2.formula)

    case DefinitionRightRule(p1,_,o1,o2) =>
      val new_proof = cleanStructuralRules(p1)
      DefinitionRightRule(new_proof,o1.formula,o2.formula)


    // Schema rules:
    case AndLeftEquivalenceRule1(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      AndLeftEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])

    case AndRightEquivalenceRule1(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      AndRightEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrLeftEquivalenceRule1(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      OrLeftEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrRightEquivalenceRule1(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      OrRightEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case AndLeftEquivalenceRule3(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      AndLeftEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case AndRightEquivalenceRule3(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      AndRightEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrLeftEquivalenceRule3(p, _, a, m) =>
      val new_proof = cleanStructuralRules(p)
      OrLeftEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrRightEquivalenceRule3(p, _, a, m) => 
      val new_proof = cleanStructuralRules(p)
      OrRightEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])


    case _ => throw new Exception("ERROR: Unexpected case while cleaning redundant structural rules.")

  }

  // Checks if a formula is weakened in a proof
  private def isWeakened(f: FormulaOccurrence, proof: LKProof) : Boolean = proof match {
    // Base case: axiom
    case Axiom(s) => false 

    // Structural rules:
    case WeakeningLeftRule(p, _, m) =>
      if(getAncestors(f).contains(m) && f =^ m) true
      else isWeakened(f, p) 
    case WeakeningRightRule(p, _, m) =>
      if(getAncestors(f).contains(m) && f =^ m) true
      else isWeakened(f, p) 
    case ContractionLeftRule(p, _, _, _, _) => isWeakened(f, p)
    case ContractionRightRule(p, _, _, _, _) => isWeakened(f, p)
    case CutRule(p1, p2, _, _, _) => isWeakened(f, p1) || isWeakened(f, p2)

    // Logical rules:
    case NegLeftRule(p, _, _, _) => isWeakened(f, p)
    case NegRightRule(p, _, _, _) => isWeakened(f, p)
    case AndLeft1Rule(p, _, _, _) => isWeakened(f, p)
    case AndLeft2Rule(p, _, _, _) => isWeakened(f, p)
    case AndRightRule(p1, p2, _, _, _, _) => isWeakened(f, p1) || isWeakened(f, p2)
    case OrRight1Rule(p, _, _, _) => isWeakened(f, p)
    case OrRight2Rule(p, _, _, _) => isWeakened(f, p)
    case OrLeftRule(p1, p2, _, _, _, _) => isWeakened(f, p1) || isWeakened(f, p2)
    case ImpLeftRule(p1, p2, _, _, _, _) => isWeakened(f, p1) || isWeakened(f, p2)
    case ImpRightRule(p, _, _, _, _) => isWeakened(f, p)
    case ForallLeftRule(p, _, _, _, _) => isWeakened(f, p) 
    case ForallRightRule(p, _, _, _, _) => isWeakened(f, p) 
    case ExistsLeftRule(p, _, _, _, _) => isWeakened(f, p)
    case ExistsRightRule(p, _, _, _, _) => isWeakened(f, p)
    case EquationLeft1Rule(p1,p2,_,_,_,_) => isWeakened(f, p1) || isWeakened(f, p2)
    case EquationLeft2Rule(p1,p2,_,_,_,_) => isWeakened(f, p1) || isWeakened(f, p2)
    case EquationRight1Rule(p1,p2,_,_,_,_) => isWeakened(f, p1) || isWeakened(f, p2)
    case EquationRight2Rule(p1,p2,_,_,_,_) => isWeakened(f, p1) || isWeakened(f, p2)
    case DefinitionLeftRule(p1,_,_,_) => isWeakened(f, p1)
    case DefinitionRightRule(p1,_,_,_) => isWeakened(f, p1)

    // Schema rules:
    case AndLeftEquivalenceRule1(p, _, a, m) => isWeakened(f, p)
    case AndRightEquivalenceRule1(p, _, a, m) => isWeakened(f, p) 
    case OrLeftEquivalenceRule1(p, _, a, m) => isWeakened(f, p)
    case OrRightEquivalenceRule1(p, _, a, m) => isWeakened(f, p)
    case AndLeftEquivalenceRule3(p, _, a, m) => isWeakened(f, p)
    case AndRightEquivalenceRule3(p, _, a, m) => isWeakened(f, p)
    case OrLeftEquivalenceRule3(p, _, a, m) => isWeakened(f, p)
    case OrRightEquivalenceRule3(p, _, a, m) => isWeakened(f, p)
    
    case _ => throw new Exception("ERROR: Unexpected rule while checking if a formula is weakened in a proof.")
  }

  // Removes the weakening on some ancestor of f (such that it is not a proper
  // subformula of f)
  private def removeWeakeningOn(f: FormulaOccurrence, proof: LKProof) : LKProof = proof match {
     case Axiom(s) => proof

    // Structural rules:
    case WeakeningLeftRule(p, _, m) => 
      if(getAncestors(f).contains(m) && f =^ m) p
      else {
        val new_proof = removeWeakeningOn(f, p) 
        WeakeningLeftRule(new_proof, m.formula)
      }
    case WeakeningRightRule(p, _, m) =>
      if(getAncestors(f).contains(m) && f =^ m) p
      else {
        val new_proof = removeWeakeningOn(f, p) 
        WeakeningRightRule(new_proof, m.formula)
      }

    case ContractionLeftRule(p, _, a1, a2, m) => 
      val new_proof = removeWeakeningOn(f, p)
      ContractionLeftRule(new_proof, a1.formula)
    case ContractionRightRule(p, _, a1, a2, m) => 
      val new_proof = removeWeakeningOn(f, p)
      ContractionRightRule(new_proof, a1.formula)
    
    case CutRule(p1, p2, _, a1, a2) =>
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      CutRule(new_proof1, new_proof2, a1.formula)

    // Logical rules:
    case NegLeftRule(p, _, a, m ) => 
      val new_proof = removeWeakeningOn(f, p)
      NegLeftRule(new_proof, a.formula)

    case NegRightRule(p, _, a, m ) =>
      val new_proof = removeWeakeningOn(f, p)
      NegRightRule(new_proof, a.formula)

    case AndLeft1Rule(p, _, a, m) =>
      val new_proof = removeWeakeningOn(f, p)
      val a2 = m.formula match {case And(_,r) => r}
      AndLeft1Rule(new_proof, a.formula, a2.asInstanceOf[HOLFormula])

    case AndLeft2Rule(p, _, a, m) =>
      val new_proof = removeWeakeningOn(f, p)
      val a2 = m.formula match {case And(l,_) => l}
      AndLeft2Rule(new_proof, a2.asInstanceOf[HOLFormula], a.formula)

    case AndRightRule(p1, p2, _, a1, a2, m) => 
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      AndRightRule(new_proof1, new_proof2, a1.formula, a2.formula)

    case OrRight1Rule(p, _, a, m) =>
      val new_proof = removeWeakeningOn(f, p)
      val a2 = m.formula match {case Or(_,r) => r}
      OrRight1Rule(new_proof, a.formula, a2.asInstanceOf[HOLFormula])

    case OrRight2Rule(p, _, a, m) =>
      val new_proof = removeWeakeningOn(f, p)
      val a2 = m.formula match {case Or(l,_) => l}
      OrRight2Rule(new_proof, a2.asInstanceOf[HOLFormula], a.formula)

    case OrLeftRule(p1, p2, _, a1, a2, m) => 
      val new_proof1 = removeWeakeningOn(f, p1) 
      val new_proof2 = removeWeakeningOn(f, p2)
      OrLeftRule(new_proof1, new_proof2, a1.formula, a2.formula)

    case ImpLeftRule(p1, p2, _, a1, a2, m) => 
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      ImpLeftRule(new_proof1, new_proof2, a1.formula, a2.formula)

    case ImpRightRule(p, _, a1, a2, m) =>
      val new_proof = removeWeakeningOn(f, p)
      ImpRightRule(new_proof, a1.formula, a2.formula)

    case ForallLeftRule(p, _, a, m, t) => 
      val new_proof = removeWeakeningOn(f, p)
      ForallLeftRule(new_proof, a.formula, m.formula, t)

    case ForallRightRule(p, _, a, m, t) => 
      val new_proof = removeWeakeningOn(f, p)
      ForallRightRule(new_proof, a.formula, m.formula, t)

    case ExistsLeftRule(p, _, a, m, t) => 
      val new_proof = removeWeakeningOn(f, p)
      ExistsLeftRule(new_proof, a.formula, m.formula, t)

    case ExistsRightRule(p, _, a, m, t) => 
      val new_proof = removeWeakeningOn(f, p)
      ExistsRightRule(new_proof, a.formula, m.formula, t)

    case EquationLeft1Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      EquationLeft1Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case EquationLeft2Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      EquationLeft2Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case EquationRight1Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      EquationRight1Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case EquationRight2Rule(p1,p2,_,o1,o2,o3) =>
      val new_proof1 = removeWeakeningOn(f, p1)
      val new_proof2 = removeWeakeningOn(f, p2)
      EquationRight2Rule(new_proof1,new_proof2,o1.formula,o2.formula,o3.formula)

    case DefinitionLeftRule(p1,_,o1,o2) =>
      val new_proof = removeWeakeningOn(f, p1)
      DefinitionLeftRule(new_proof,o1.formula,o2.formula)

    case DefinitionRightRule(p1,_,o1,o2) =>
      val new_proof = removeWeakeningOn(f, p1)
      DefinitionRightRule(new_proof,o1.formula,o2.formula)


     // Schema rules:
    case AndLeftEquivalenceRule1(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      AndLeftEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])

    case AndRightEquivalenceRule1(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      AndRightEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrLeftEquivalenceRule1(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      OrLeftEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrRightEquivalenceRule1(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      OrRightEquivalenceRule1(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case AndLeftEquivalenceRule3(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      AndLeftEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case AndRightEquivalenceRule3(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      AndRightEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrLeftEquivalenceRule3(p, _, a, m) =>
      val new_proof = removeWeakeningOn(f, p)
      OrLeftEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])
    
    case OrRightEquivalenceRule3(p, _, a, m) => 
      val new_proof = removeWeakeningOn(f, p)
      OrRightEquivalenceRule3(new_proof, a.formula.asInstanceOf[SchemaFormula], m.formula.asInstanceOf[SchemaFormula])

    case _ => throw new Exception("ERROR: Unexpected rule while removing weakening of a formula.")
  }

  // Adds weakenings to p in order to obtain the sequent s as the end-sequent.
  // Note: s should be a super-set of p's end-sequent.
  private def addWeakenings(p: LKProof, s: Sequent) = {

    // Getting rid of FormulaOccurrence wrappers...
    val root_ant = p.root.antecedent.map(x => x.formula)
    val root_suc = p.root.succedent.map(x => x.formula)
    val s_ant = s.antecedent.map(x => x.formula)
    val s_suc = s.succedent.map(x => x.formula)

    assert(root_ant.forall(e => s_ant.contains(e)) && root_suc.forall(e => s_suc.contains(e)))

    // Take formulas that occur in s and do not occur in p's end-sequent
    val diff_ant = s_ant.diff(root_ant) 
    val diff_suc = s_suc.diff(root_suc)

    // Add weakenings left
    val wl = diff_ant.foldRight(p) {case (f, proof) =>
      WeakeningLeftRule(proof, f)
    }
    // Add weakenings right
    diff_suc.foldRight(wl) {case (f, proof) =>
      WeakeningRightRule(proof, f)
    }
  }
}
